% Parameters for SIR model
S0 = 990; I0 = 10; R0 = 0; T = 100;
N = S0 + I0 + R0; % Total population
beta = 0.3; gamma = 0.1;

% Fine timestep simulation (h = 1)
h_fine = 1;
steps_fine = T / h_fine + 1;
time_vec_fine = 0:h_fine:T;
[S_fine, I_fine, R_fine] = runge_kutta(S0, I0, R0, beta, gamma, h_fine, steps_fine);

% Normalize by population size
S_fine = S_fine / N;
I_fine = I_fine / N;
R_fine = R_fine / N;

% Coarse timestep simulation (h = 2)
h_coarse = 2;
steps_coarse = T / h_coarse + 1;
time_vec_coarse = 0:h_coarse:T;
[S_coarse, I_coarse, R_coarse] = runge_kutta(S0, I0, R0, beta, gamma, h_coarse, steps_coarse);

% Normalize coarse results
S_coarse = S_coarse / N;
I_coarse = I_coarse / N;
R_coarse = R_coarse / N;

% Odd time points for interpolation
odd_times = 1:2:T-1;

% Linear interpolation
linear_S = arrayfun(@(t) newton_interp(time_vec_coarse(1:2), S_coarse(1:2), t), odd_times);
linear_I = arrayfun(@(t) newton_interp(time_vec_coarse(1:2), I_coarse(1:2), t), odd_times);
linear_R = arrayfun(@(t) newton_interp(time_vec_coarse(1:2), R_coarse(1:2), t), odd_times);

% Quadratic interpolation (robust implementation)
quadratic_S = arrayfun(@(t) robust_quadratic_interp(time_vec_coarse, S_coarse, t), odd_times);
quadratic_I = arrayfun(@(t) robust_quadratic_interp(time_vec_coarse, I_coarse, t), odd_times);
quadratic_R = arrayfun(@(t) robust_quadratic_interp(time_vec_coarse, R_coarse, t), odd_times);

% Extract exact values at odd time points
exact_S_odd = S_fine(round(odd_times / h_fine) + 1);
exact_I_odd = I_fine(round(odd_times / h_fine) + 1);
exact_R_odd = R_fine(round(odd_times / h_fine) + 1);

% Compute scalar L2 errors using the provided formula
N_int = length(odd_times); % Total number of interpolated points

% Linear Interpolation Errors
linear_S_error = sqrt(sum((linear_S(:) - exact_S_odd(:)).^2) / N_int);
linear_I_error = sqrt(sum((linear_I(:) - exact_I_odd(:)).^2) / N_int);
linear_R_error = sqrt(sum((linear_R(:) - exact_R_odd(:)).^2) / N_int);

% Quadratic Interpolation Errors
quadratic_S_error = sqrt(sum((quadratic_S(:) - exact_S_odd(:)).^2) / N_int);
quadratic_I_error = sqrt(sum((quadratic_I(:) - exact_I_odd(:)).^2) / N_int);
quadratic_R_error = sqrt(sum((quadratic_R(:) - exact_R_odd(:)).^2) / N_int);

% Create and display a table of scalar L2 errors
error_table = table(["Linear"; "Quadratic"], ...
                    [linear_S_error; quadratic_S_error], ...
                    [linear_I_error; quadratic_I_error], ...
                    [linear_R_error; quadratic_R_error], ...
                    'VariableNames', {'Method', 'S_Error', 'I_Error', 'R_Error'});

disp('L2 Error Table:');
disp(error_table);

% Plot results with solid lines
figure;
subplot(3, 1, 1);
plot(time_vec_fine, S_fine, 'k-', 'LineWidth', 1.5, 'DisplayName', 'Exact');
hold on;
plot(odd_times, linear_S, 'r-', 'LineWidth', 1.5, 'DisplayName', 'Linear');
plot(odd_times, quadratic_S, 'g-', 'LineWidth', 1.5, 'DisplayName', 'Quadratic');
title('S(t)'); legend; grid on;

subplot(3, 1, 2);
plot(time_vec_fine, I_fine, 'k-', 'LineWidth', 1.5, 'DisplayName', 'Exact');
hold on;
plot(odd_times, linear_I, 'r-', 'LineWidth', 1.5, 'DisplayName', 'Linear');
plot(odd_times, quadratic_I, 'g-', 'LineWidth', 1.5, 'DisplayName', 'Quadratic');
title('I(t)'); legend; grid on;

subplot(3, 1, 3);
plot(time_vec_fine, R_fine, 'k-', 'LineWidth', 1.5, 'DisplayName', 'Exact');
hold on;
plot(odd_times, linear_R, 'r-', 'LineWidth', 1.5, 'DisplayName', 'Linear');
plot(odd_times, quadratic_R, 'g-', 'LineWidth', 1.5, 'DisplayName', 'Quadratic');
title('R(t)'); legend; grid on;

% Supporting Functions

% Runge-Kutta implementation (same as original)

function [S, I, R] = runge_kutta(S0, I0, R0, beta, gamma, h, steps)
    S = zeros(steps, 1);
    I = zeros(steps, 1);
    R = zeros(steps, 1);
    S(1) = S0; I(1) = I0; R(1) = R0;
    N = S0 + I0 + R0;

    for t = 1:steps-1
        dS1 = -beta * S(t) * I(t) / N;
        dI1 = beta * S(t) * I(t) / N - gamma * I(t);
        dR1 = gamma * I(t);

        dS2 = -beta * (S(t) + h * dS1 / 2) * (I(t) + h * dI1 / 2) / N;
        dI2 = beta * (S(t) + h * dS1 / 2) * (I(t) + h * dI1 / 2) / N - gamma * (I(t) + h * dI1 / 2);
        dR2 = gamma * (I(t) + h * dI1 / 2);

        dS3 = -beta * (S(t) + h * dS2 / 2) * (I(t) + h * dI2 / 2) / N;
        dI3 = beta * (S(t) + h * dS2 / 2) * (I(t) + h * dI2 / 2) / N - gamma * (I(t) + h * dI2 / 2);
        dR3 = gamma * (I(t) + h * dI2 / 2);

        dS4 = -beta * (S(t) + h * dS3) * (I(t) + h * dI3) / N;
        dI4 = beta * (S(t) + h * dS3) * (I(t) + h * dI3) / N - gamma * (I(t) + h * dI3);
        dR4 = gamma * (I(t) + h * dI3);

        S(t+1) = S(t) + h * (dS1 + 2*dS2 + 2*dS3 + dS4) / 6;
        I(t+1) = I(t) + h * (dI1 + 2*dI2 + 2*dI3 + dI4) / 6;
        R(t+1) = R(t) + h * (dR1 + 2*dR2 + 2*dR3 + dR4) / 6;
    end
end

% Newton interpolation for linear
function y_interp = newton_interp(x_vals, y_vals, x)
    n = length(x_vals);
    dd_table = zeros(n, n);
    dd_table(:, 1) = y_vals;
    for j = 2:n
        for i = 1:n-j+1
            dd_table(i, j) = (dd_table(i+1, j-1) - dd_table(i, j-1)) / (x_vals(i+j-1) - x_vals(i));
        end
    end
    y_interp = dd_table(1, 1);
    product = 1;
    for i = 1:n-1
        product = product * (x - x_vals(i));
        y_interp = y_interp + product * dd_table(1, i+1);
    end
end

% Robust quadratic interpolation
function y_interp = robust_quadratic_interp(x_vals, y_vals, x)
    n = length(x_vals);
    if n < 3
        error('At least 3 points are required for quadratic interpolation.');
    end
    [~, idx] = min(abs(x_vals - x));
    idx = max(2, min(idx, n-1));
    x_nearest = x_vals(idx-1:idx+1);
    y_nearest = y_vals(idx-1:idx+1);
    p = polyfit(x_nearest, y_nearest, 2);
    y_interp = polyval(p, x);
end
